import { JsonSchemaCommand } from ".";
import * as jsonSchema from "json-schema";

/** Collection of fixes for the json schema dictionary generated by parsing redis-doc's command.json */
export const fixupSchema = (schema: Record<string, JsonSchemaCommand>) => {
    const clone: typeof schema = JSON.parse(JSON.stringify(schema));

    fixSetEnum(clone);

    fixArrayRepliesManually(clone);

    return clone;
};

export const fixupExample = (example: string) => {
    const array = [example] // use array as a stupid monad-like data structure
        .map(fixGeoradiusExample)
        .map(fixLposExample)
        .map(s => s);

    return array[0];
};

export const fixupClientTypescript = (command: string) => (signature: string) => {
    if (command.toUpperCase() === "HGETALL") {
        return signature.replace("Array<unknown>", "Record<string, string>");
    }
    return signature;
};

export const fixupGeneratedCode = (filename: string) => (code: string): string => {
    const array: string[] = [code] // use array as a stupid monad-like data structure
        .map(fixKeyWeightsOverlyComplexParsingIssue)
        .map(catchDecrOutOfRange(filename))
        .map(unsupportedNodeRedis(filename))
        .map(s => s);

    return array[0];
};

/** https://github.com/redis/redis-doc/pull/1232 */
function fixSetEnum(schema: Record<string, JsonSchemaCommand>) {
    const badSetArg = schema.SET.arguments.find(
        a => a.name === "expiration" && a.schema.enum?.join(",") === "EX seconds,PX milliseconds,KEEPTTL"
    )!;
    badSetArg.schema = {
        anyOf: [
            {
                type: "array",
                items: [
                    // format: `["EX", 123]` or `["PX", 123]`
                    { type: "string", enum: ["EX", "PX"] },
                    { type: "number" },
                ],
            },
            {
                type: "string",
                const: "KEEPTTL",
            },
        ],
    };
}

function fixArrayRepliesManually(schema: Record<string, JsonSchemaCommand>) {
    const commandsWithArrayReplies = Object.entries(schema).filter(entry => entry[1].return.type === "array");

    const manuallyFixedUp: Record<string, jsonSchema.JSONSchema7 & { type: "array" }> = {
        GEOHASH: { type: "array", items: { type: "string" } },
        KEYS: { type: "array", items: { type: "string" } },
        HKEYS: { type: "array", items: { type: "string" } },
        HMGET: { type: "array", items: { anyOf: [{ type: "string" }, { type: "null" }] } },
        HVALS: { type: "array", items: { type: "string" } },
        LRANGE: { type: "array", items: { type: "string" } },
        MGET: { type: "array", items: { anyOf: [{ type: "string" }, { type: "null" }] } },
        SDIFF: { type: "array", items: { type: "string" } },
        SINTER: { type: "array", items: { type: "string" } },
        SMEMBERS: { type: "array", items: { type: "string" } },
        SUNION: { type: "array", items: { type: "string" } },
        TIME: { type: "array", items: { type: "number" } },
        ZPOPMAX: { type: "array", items: { type: "string" } },
        ZPOPMIN: { type: "array", items: { type: "string" } },
        ZRANGE: { type: "array", items: { type: "string" } },
        ZREVRANGE: { type: "array", items: { type: "string" } },
        ZRANGEBYLEX: { type: "array", items: { type: "string" } },
        ZREVRANGEBYLEX: { type: "array", items: { type: "string" } },
        ZRANGEBYSCORE: { type: "array", items: { type: "string" } },
    };

    commandsWithArrayReplies.forEach(([name, command]) => {
        if (name in manuallyFixedUp) {
            command.return = manuallyFixedUp[name] || command.return;
        } else if (!command.return.items && process.env.FIND_GENERIC_ARRAYS) {
            console.warn(`${name} has a generic array return type`);
        }
    });
}

// https://github.com/redis/redis-doc/pull/1414
function fixGeoradiusExample(example: string) {
    const withArgsFlipped = "GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD";
    return example === withArgsFlipped ? example.replace("WITHDIST WITHCOORD", "WITHCOORD WITHDIST") : example;
}

function fixLposExample(example: string) {
    const withArgsFlipped = `LPOS mylist 3 COUNT 0 RANK 2`;
    return example === withArgsFlipped ? example.replace("COUNT 0 RANK 2", "RANK 2 COUNT 0") : example;
}

function unsupportedNodeRedis(filename: string) {
    const unsupported = ["lmove", "lpos", "smismember", "zinter", "zmscore", "zunion"];
    const match = unsupported.find(u => filename.endsWith(`${u}.md`));
    if (match) {
        return (code: string) => `// ${match} not supported by node_redis! ${code}`;
    }
    return (code: string) => code;
}

function fixKeyWeightsOverlyComplexParsingIssue(code: string) {
    if (code.match(/(zunionstore|zinterstore).*WEIGHTS/)) {
        return [`// @ts-expect-error (not smart enough to deal with numkeys)`, code].join("\n");
    }
    if (code.match(/(zunion|zinter).*"zset1","zset2"/)) {
        return code.replace(`"zset1","zset2"`, `["zset1", "zset2"]`);
    }
    return code;
}

function catchDecrOutOfRange(filename: string) {
    if (filename.endsWith("decr.md")) {
        const catchable = `outputs.r3 = await client.decr("mykey")`;
        return (code: string) => code.replace(catchable, catchable + `.catch(e => e)`);
    }
    return (code: string) => code;
}
